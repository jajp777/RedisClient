<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-53263543-1', 'auto');
          ga('send', 'pageview');
    </script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>RedisClient by vtortola</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>RedisClient</h1>
        <h2>.NET Redis client focused on LUA scripting</h2>
        <a href="https://github.com/vtortola/RedisClient" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <p>An experimental .NET Redis client that uses a special syntax for easing LUA script invocation named <a href="//github.com/vtortola/RedisClient/wiki/Procedures">"procedures"</a>. The interface is based on templated strings, allowing to execute custom defined server side procedures as regular Redis commands. Executions are done through "channels", in essence virtual connections that provide seamless access to Redis through three different connection pools.</p>

<ul>
<li>Templated strings interface <a href="//github.com/vtortola/RedisClient/wiki/Parameter-binding">(more about parameter binding)</a>.</li>
<li>Transparent connection management <a href="//github.com/vtortola/RedisClient/wiki/Connection-management">(more about connection management)</a>.</li>
<li>Basic output binding <a href="//github.com/vtortola/RedisClient/wiki/Getting-results">(more about output binding)</a>.</li>
<li>Server-side scripting through procedures <a href="//github.com/vtortola/RedisClient/wiki/Procedures">(more about procedures)</a>.</li>
<li>A <a href="//github.com/vtortola/RedisClient/wiki/Procedure-Debugger">debugging tool for procedures</a> is available in this repository.</li>
<li>Support for asynchronous, synchronous and "fire and forget" operations.</li>
<li>
<strong>Redis Cluster</strong>: Not supported at the moment, but is the next thing in my roadmap.</li>
</ul>

<h3>
<a id="why--procedures" class="anchor" href="#why--procedures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why  <a href="//github.com/vtortola/RedisClient/wiki/Procedures">procedures</a>?</h3>

<ul>
<li>They have all the benefits of regular LUA scripting in Redis, like atomicity and avoiding multiple round trips to the server, since a procedure is just a way to wrap regular LUA scripts.</li>
<li>Multiple procedures can be defined in a same text file since they are limited by <code>proc</code> and <code>endproc</code> boundaries.</li>
<li>RedisClient handles the <a href="//github.com/vtortola/RedisClient/wiki/Procedure-management">procedure deployment</a>.</li>
<li>Procedures are invoked by name rather than using <code>EVAL</code> or <code>EVALSHA</code>.</li>
<li>Instead passing parameter values in <code>KEYS</code> and <code>ARGV</code> arrays, and having to hardcore the index location of the data in those arrays, <strong>named parameters are used</strong>.</li>
<li>
<a href="//github.com/vtortola/RedisClient/wiki/Procedures#parameter-cardinality"><strong>Array parameters of arbitrary length</strong></a> are supported, being the length of those arrays defined at parameter value binding time.</li>
<li>Procedures in RedisClient use the same <a href="//github.com/vtortola/RedisClient/wiki/Parameter-binding">parameter binding</a> capabilities than for regular Redis commands.</li>
<li>Procedure results can be <a href="//github.com/vtortola/RedisClient/wiki/Getting-results">inspected</a> as any other Redis command.</li>
<li>
<a href="//github.com/vtortola/RedisClient/wiki/Procedures">Learn more about procedures</a>.</li>
</ul>

<h4>
<a id="simple-procedure-example" class="anchor" href="#simple-procedure-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple procedure example</h4>

<p>Imagine a catalog application, with products/services defined as different hashes in the Redis database, where each hash contains the properties of each product, like 
name, url, stock, description, picture url, etc... Also you have different zsets containing the keys of all products sorted by a specific properties or just grouped by categories. 
Since there may be a big amount of products, pagination is needed to avoid blowing up the server response with too much data. </p>

<p>How is this pagination achieved <strong>without server side scripting</strong>? First querying the zset with the desired range to obtain the list of hash keys that need to be retrieved, and then retrieving
each key (usually) one by one. </p>

<p>This can be expedited and simplified <strong>with server-side scripting</strong>. For example, you can use a procedure to get the list of products directly, without extra round trips:</p>

<pre><code>proc ZPaginate(zset, page, itemsPerPage)

    local start  = page * itemsPerPage
    local stop = start + itemsPerPage - 1
    local items = redis.call('ZREVRANGE', zset, start, stop)

    local result = {}

    for index, key in ipairs(items) do
        result[index] = redis.call('HGETALL', key)
    end

    return result
endproc
</code></pre>

<p>Using the templated string syntax you can invoke this procedure easily:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Execute procedure</span>
<span class="pl-k">var</span> result = channel.Execute(<span class="pl-s"><span class="pl-pds">"</span>ZPaginate @key @page @items<span class="pl-pds">"</span></span>, 
                              <span class="pl-k">new</span> { key = <span class="pl-s"><span class="pl-pds">"</span>products:bydate<span class="pl-pds">"</span></span>,  page=<span class="pl-c1">3</span>, items=<span class="pl-c1">10</span> });

<span class="pl-c">// Expand result of the first line as a collection of results</span>
<span class="pl-k">var</span> hashes = result[<span class="pl-c1">0</span>].AsResults();

<span class="pl-c">// Bind each hash to an object</span>
<span class="pl-c">// Where &lt;Product&gt; is a class with properties that match the hash keys.</span>
<span class="pl-k">var</span> products = hashes.Select(h =&gt; h.AsObjectCollation&lt;Product&gt;()).ToArray();</pre></div>

<p>Server side scripting has multiple advantages, like preventing multiple round trips to the Redis instance or atomicity. <a href="//github.com/vtortola/RedisClient#executing-procedures">Continue reading about procedures</a> </p>

<h4>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Performance</h4>

<p>A <a href="//github.com/vtortola/RedisClient/wiki/Performance">performance comparison</a> shows the that the performance is close to other well known clients.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/Performance"><img src="http://vtortola.github.io/RCPerf/pipeline.png" height="300"></a>
<a href="//github.com/vtortola/RedisClient/wiki/Performance"><img src="http://vtortola.github.io/RCPerf/transactions.png" height="300"></a></p>

<h4>
<a id="use-in-a-web-application" class="anchor" href="#use-in-a-web-application" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Use in a web application</h4>

<p>Also in this repository you will find <a href="//github.com/vtortola/RedisClient/wiki/SimpleQA-:-A-proof-of-concept">SimpleQA</a>, a proof of concept of a <em>Q&amp;A</em> application using RedisClient.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/SimpleQA-:-A-proof-of-concept"><img src="http://vtortola.github.io/SimpleQA/Mini.png?version=3"></a></p>

<h2>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting started</h2>

<ul>
<li>
<a href="#installing">Installing</a>.</li>
<li>
<a href="#setting-it-up">Setting it up</a>.</li>
<li>
<a href="#binding-parameters">Binding parameters</a>.</li>
<li>
<a href="#getting-results">Getting results</a>.</li>
<li>
<a href="#subscribing-to-channels">Subscribing to channels</a>.</li>
<li>
<a href="#executing-procedures">Executing procedures</a>.</li>
</ul>

<h3>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing</h3>

<p>The alpha version is <a href="https://www.nuget.org/packages/vtortola.RedisClient/">available in NuGet</a>.</p>

<pre><code>PM&gt; Install-Package vtortola.RedisClient -Pre
</code></pre>

<h3>
<a id="setting-it-up" class="anchor" href="#setting-it-up" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setting it up</h3>

<p>The API has two fundamental parts:</p>

<ul>
<li>
<code>RedisClient</code> class handles the connection management. Usually you have one instance across all your AppDomain (or two instances if you have master/slave). It is a thread safe object, that usually is cached for the extend of your application lifetime.</li>
</ul>

<div class="highlight highlight-source-cs"><pre>_client = <span class="pl-k">new</span> RedisClient(endpoint))
<span class="pl-k">await</span> _client.ConnectAsync(CancellationToken.None).ConfigureAwait(<span class="pl-c1">false</span>);</pre></div>

<ul>
<li>
<code>IRedisChannel</code> interface is used to execute commands. Channels are short lived, cheap to create, non-thread safe objects that represent virtual connections to Redis. Channels provide seamless operation for commanding and subscribing.</li>
</ul>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">await</span> channel.ExecuteAsync(<span class="pl-s"><span class="pl-pds">"</span>incr mykey<span class="pl-pds">"</span></span>)
                 .ConfigureAwait(<span class="pl-c1">false</span>);
}</pre></div>

<p>     It is possible to execute multiple statements per command, splitting them with line breaks. Statements are pipelined to the same connection (but still they may be interpolated with other commands by Redis, use <code>MULTI</code> if you want to avoid it).</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">await</span> channel.ExecuteAsync(@<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">                  incr mykey</span>
<span class="pl-s">                  decr otherkey</span>
<span class="pl-s">                  subscribe topic<span class="pl-pds">"</span></span>)
                  .ConfigureAwait(<span class="pl-c1">false</span>);
}</pre></div>

<p><a href="//github.com/vtortola/RedisClient/wiki/Options">Read more about available options</a>.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/Connection-management">Read more about connection management</a>.</p>

<h3>
<a id="binding-parameters" class="anchor" href="#binding-parameters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Binding parameters</h3>

<p>Although is possible to use RedisClient composing strings dynamically, it is unrecommended. Providing command templates will increase the performance since then the command execution plan can be cached.</p>

<p>Parameter binding works passing an object which properties will be bind to the command parameters, identified by a starting '@'. Only <a href="https://msdn.microsoft.com/en-us/library/exx3b86w(v=vs.80).aspx">integral types</a>, <code>String</code>, <code>DateTime</code> and their <code>IEnumerable&lt;&gt;</code> are supported. Commands should always start by a Redis command or a procedure alias.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">await</span> channel.ExecuteAsync(@<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">                  incr @counterKey</span>
<span class="pl-s">                  set currentDateKey @date<span class="pl-pds">"</span></span>,
                  <span class="pl-k">new</span> { counterKey = <span class="pl-s"><span class="pl-pds">"</span>mycounter<span class="pl-pds">"</span></span>, date = DateTime.Now })
                  .ConfigureAwait(<span class="pl-c1">false</span>);
}</pre></div>

<p>Collections are added to the command as sequences. For example, it is possible to add multiple items with <code>SADD</code>:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">await</span> channel.ExecuteAsync(<span class="pl-s"><span class="pl-pds">"</span>sadd @setKey @data<span class="pl-pds">"</span></span>,
                  <span class="pl-k">new</span> { setKey = <span class="pl-s"><span class="pl-pds">"</span>myset<span class="pl-pds">"</span></span>, data = <span class="pl-k">new</span> [] { <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span> } })
                 .ConfigureAwait(<span class="pl-c1">false</span>);
}</pre></div>

<p>Object's properties, <code>IEnumerable&lt;Tuple&lt;,&gt;&gt;</code> and <code>IEnumerable&lt;KeyValuePair&lt;,&gt;&gt;</code> can be sequenced with the <code>Parameter</code> helper. This is handy for example saving objects as hashes:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">await</span> channel.ExecuteAsync(<span class="pl-s"><span class="pl-pds">"</span>hmset myObject @data<span class="pl-pds">"</span></span>,
                  <span class="pl-k">new</span> { data = Parameter.SequenceProperties(myObjectInstance))
                 .ConfigureAwait(<span class="pl-c1">false</span>);
}</pre></div>

<p><a href="//github.com/vtortola/RedisClient/wiki/Parameter-binding">Read more about parameter binding</a>.</p>

<h3>
<a id="getting-results" class="anchor" href="#getting-results" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting results</h3>

<p>A command execution result implements <code>IRedisResults</code>, which allows to inspect the return in every single statement of the command through a <code>IRedisResultInspector</code> per statement. </p>

<ul>
<li>Each statement correlates to a position in the <code>IRedisResults</code> items. First statement is item 0, and so on.</li>
<li>
<code>.RedisType</code>: indicates the result type.</li>
<li>If the result is an error, accessing the statement result will throw a <code>RedisClientCommandException</code> with the details of the Redis error. It is possible to get the exception without throwing it using <code>.GetException()</code>.</li>
<li>
<code>.GetXXX</code> methods: will try to read the value as <code>XXX</code> type, and will throw an <code>RedisClientCastException</code> if the data is not in the expected type.</li>
<li>
<code>.AsXXX</code> methods: will try to read the value as <code>XXX</code> type, or parse it as <code>XXX</code> (there is no <code>.GetDouble()</code> because Redis only returns string, integer or error, but there is a <code>.AsDouble()</code>.</li>
<li>
<code>.AsResults()</code> method: will expand a single result as another collection of <code>IRedisResultInspector</code>. This is useful when a LUA script is returning an array of other Redis types.</li>
<li>
<code>.AsObjectCollation&lt;T&gt;()</code> allows to bind the result to an object by parsing a sequence of key-value pairs, and bind it to the object properties. For example <code>member1 value1 member2 value2</code> will be bound as <code>{ member1 = "value1", member2 = "value2" }</code>.</li>
<li>
<p><code>.AsDictionaryCollation&lt;TKey, TValue&gt;()</code> allows to bind the result to an object by parsing a sequence of key-value pairs as <code>KeyValuePair&lt;&gt;</code>.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">var</span> results = <span class="pl-k">await</span> channel.ExecuteAsync(@<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">                                incr mycounter</span>
<span class="pl-s">                                hgetall @customer<span class="pl-pds">"</span></span>,
                                <span class="pl-k">new</span> { customer = <span class="pl-s"><span class="pl-pds">"</span>customer:<span class="pl-pds">"</span></span> + customerId} )
                                .ConfigureAwait(<span class="pl-c1">false</span>);
    <span class="pl-k">var</span> <span class="pl-k">value</span> = results[<span class="pl-c1">0</span>].GetInteger();
    <span class="pl-k">var</span> obj = results[<span class="pl-c1">1</span>].AsObjectCollation&lt;Customer&gt;();
}</pre></div>
</li>
</ul>

<p><a href="//github.com/vtortola/RedisClient/wiki/Getting-results">Read more about getting results</a>.</p>

<h3>
<a id="subscribing-to-channels" class="anchor" href="#subscribing-to-channels" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Subscribing to channels</h3>

<p><code>IRedisChannel</code> exposes a <code>NotificationHandler</code> property that can be used to get or set a handler for messages received by this channel. The handler will receive <code>RedisNotification</code> objects containing the message data.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = Client.CreateChannel())
{
    channel.NotificationHandler = msg =&gt; Console.WriteLine(msg.Content); <span class="pl-c">// will print 'whatever'</span>
    channel.Execute(<span class="pl-s"><span class="pl-pds">"</span>psubscribe h?llo<span class="pl-pds">"</span></span>);
    channel.Execute(<span class="pl-s"><span class="pl-pds">"</span>publish hello whatever<span class="pl-pds">"</span></span>);
}</pre></div>

<p><strong>Note:</strong> You may feel tempted to put the <code>SUBSCRIBE</code> and <code>PUBLISH</code> statements in the same command, however it won't work because they will be executed in parallel in subscriber and commander connections respectively. Although technically possible to do, I considered this a very unlikely scenario, so in alas of better performace parallel execution is used.</p>

<p>Subscriptions are automatically cleared on <code>IRedisChannel.Dispose()</code>, so make sure you always dispose your channels.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/Subscribing">Read more about subscribing to topics</a>.</p>

<h3>
<a id="executing-procedures" class="anchor" href="#executing-procedures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Executing procedures</h3>

<p>Rather than executing LUA scripts directly, they need to be wrapped in what is called a procedure:</p>

<pre><code>proc Sum(a, b)
    return a + b
endproc
</code></pre>

<p>Procedures are loaded in the configuration, and they are automatically deployed to Redis when connecting the first time. Multiple procedures can be uploaded from the same reader.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> options = <span class="pl-k">new</span> RedisClientOptions()
options
  .Procedures
  .Load(<span class="pl-k">new</span> StringReader(@<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">     proc Sum(a, b)</span>
<span class="pl-s">       return a + b</span>
<span class="pl-s">     endproc<span class="pl-pds">"</span></span>));</pre></div>

<p>Then they can be invoked as normal Redis commands:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">var</span> result = <span class="pl-k">await</span> channel.ExecuteAsync(<span class="pl-s"><span class="pl-pds">"</span>Sum 1 2<span class="pl-pds">"</span></span>)
                              .ConfigureAwait(<span class="pl-c1">false</span>);
    <span class="pl-k">var</span> <span class="pl-k">value</span> = result[<span class="pl-c1">0</span>].GetInteger();
}</pre></div>

<p>Procedures accepts single and collection parameters:</p>

<ul>
<li>
<code>parameterName</code> will expect a single value'.</li>
<li>
<code>parameterName[]</code> will expect one or more parameters. They are <a href="https://www.lua.org/pil/11.1.html">LUA arrays</a>.</li>
</ul>

<p>Also, parameters can be passed as keys to the script (important for clustering) using the <code>$</code> prefix, either in single or collection parameters. The parameter (or parameters) will be passed in <code>KEYS</code> rather than in <code>ARGV</code>.</p>

<p>Quick example:</p>

<pre><code>-- sums the content of a and stored the content
-- into the key specified in &lt;asum&gt;
proc sumAndStore($asum, a[])
   local function sum(t)
       local sum = 0
       for i=1, table.getn(t), 1 
       do 
          sum = sum + t[i]
       end
       return sum
   end
   local result = sum(a)
   return redis.call('set', asum, result)
endproc
</code></pre>

<p>Invoking:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> (<span class="pl-k">var</span> channel = _client.CreateChannel())
{
    <span class="pl-k">var</span> result = <span class="pl-k">await</span> channel.ExecuteAsync(@<span class="pl-s"><span class="pl-pds">"</span></span>
<span class="pl-s">                               sumAndStore @key @values<span class="pl-pds">"</span></span>,
                               <span class="pl-k">new</span> { key = <span class="pl-s"><span class="pl-pds">"</span>mysum<span class="pl-pds">"</span></span>, values = <span class="pl-k">new</span> [] { <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>} }
                               ).ConfigureAwait(<span class="pl-c1">false</span>);
    result[<span class="pl-c1">0</span>].AssertOK();
}</pre></div>

<p>This will store the value <code>6</code> as string in the key <code>mysum</code> and will return <code>OK</code>. The value <code>mysum</code> is passed in <code>KEYS</code> rather than in <code>ARGV</code>.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/Procedures">Read more about procedures</a>.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/Procedure-management">Read more about procedures management</a>.</p>

<p><a href="//github.com/vtortola/RedisClient/wiki/Options">Read more about available options</a>.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/vtortola/RedisClient/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/vtortola/RedisClient/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>
          <p><a href="https://ci.appveyor.com/project/vtortola/redisclient/branch/master"><img src="https://ci.appveyor.com/api/projects/status/we9e8or6ajlm72pu/branch/master?svg=true" alt="Build status"></a></p>
          <p class="repo-owner"><a href="https://github.com/vtortola/RedisClient"></a> is maintained by <a href="https://github.com/vtortola">vtortola</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
